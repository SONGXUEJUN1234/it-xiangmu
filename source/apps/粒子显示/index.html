<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>霓虹粒子网络 - Neon Particle Network</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #050508;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .ui {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 10;
            color: #fff;
            pointer-events: none;
        }

        .ui h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(90deg, #00f5ff, #ff00ff, #00f5ff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient 3s ease infinite;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        @keyframes gradient {
            0%, 100% { background-position: 0% center; }
            50% { background-position: 200% center; }
        }

        .ui .subtitle {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 10px;
            letter-spacing: 0.15em;
        }

        .ui .stats {
            margin-top: 20px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Courier New', monospace;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.3);
            color: #00f5ff;
            font-size: 0.85rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border-radius: 4px;
        }

        .btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.pink {
            border-color: rgba(255, 0, 255, 0.3);
            color: #ff00ff;
        }

        .btn.pink:hover {
            background: rgba(255, 0, 255, 0.1);
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            pointer-events: none;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 2px solid;
            pointer-events: none;
            animation: rippleEffect 1s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 200px;
                height: 200px;
                opacity: 0;
                margin-left: -100px;
                margin-top: -100px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui">
        <h1>Neon Network</h1>
        <div class="subtitle">交互式粒子系统</div>
        <div class="stats">
            <div>粒子数: <span id="particleCount">0</span></div>
            <div>连接数: <span id="connectionCount">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <div class="hint">移动鼠标控制粒子 · 点击产生冲击波</div>

    <div class="controls">
        <button class="btn" onclick="changeMode('cyan')">青色模式</button>
        <button class="btn pink" onclick="changeMode('magenta')">紫色模式</button>
        <button class="btn" onclick="toggleGravity()">重力开关</button>
        <button class="btn pink" onclick="explodeAll()">全员爆炸</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let mouse = { x: null, y: null, radius: 150 };
        let animationId;
        let mode = 'cyan';
        let gravity = false;
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        // 配色方案
        const colors = {
            cyan: {
                primary: '#00f5ff',
                secondary: '#0080ff',
                glow: 'rgba(0, 245, 255, 0.5)',
                line: 'rgba(0, 245, 255, '
            },
            magenta: {
                primary: '#ff00ff',
                secondary: '#ff0080',
                glow: 'rgba(255, 0, 255, 0.5)',
                line: 'rgba(255, 0, 255, '
            }
        };

        // 调整画布大小
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // 粒子类
        class Particle {
            constructor(x, y, isExplosion = false) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.size = Math.random() * 3 + 1;
                
                if (isExplosion) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 8 + 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.life = 1;
                    this.decay = Math.random() * 0.02 + 0.01;
                } else {
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = (Math.random() - 0.5) * 1.5;
                    this.life = 1;
                    this.decay = 0;
                }
                
                this.isExplosion = isExplosion;
                this.baseX = this.x;
                this.baseY = this.y;
                this.density = Math.random() * 30 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.angleSpeed = (Math.random() - 0.5) * 0.02;
            }

            update() {
                if (this.isExplosion) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    this.life -= this.decay;
                    this.size *= 0.98;
                    return this.life > 0;
                }

                // 重力效果
                if (gravity) {
                    this.vy += 0.1;
                    if (this.y > height - this.size) {
                        this.y = height - this.size;
                        this.vy *= -0.6;
                    }
                }

                // 鼠标交互
                if (mouse.x != null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < mouse.radius) {
                        const force = (mouse.radius - distance) / mouse.radius;
                        const directionX = dx / distance;
                        const directionY = dy / distance;
                        
                        if (distance < 50) {
                            // 太近时推开
                            this.vx -= directionX * force * 2;
                            this.vy -= directionY * force * 2;
                        } else {
                            // 跟随鼠标
                            this.vx += directionX * force * 0.5;
                            this.vy += directionY * force * 0.5;
                        }
                    }
                }

                // 自然飘动
                this.angle += this.angleSpeed;
                this.vx += Math.cos(this.angle) * 0.02;
                this.vy += Math.sin(this.angle) * 0.02;

                // 速度限制
                const maxSpeed = 4;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // 更新位置
                this.x += this.vx;
                this.y += this.vy;

                // 边界处理
                if (!gravity) {
                    if (this.x < 0 || this.x > width) this.vx *= -1;
                    if (this.y < 0 || this.y > height) this.vy *= -1;
                    
                    this.x = Math.max(0, Math.min(width, this.x));
                    this.y = Math.max(0, Math.min(height, this.y));
                } else {
                    if (this.x < 0 || this.x > width) this.vx *= -1;
                    this.x = Math.max(0, Math.min(width, this.x));
                    if (this.y < -100) this.y = height + 100;
                }

                // 速度衰减
                this.vx *= 0.99;
                this.vy *= 0.99;

                return true;
            }

            draw() {
                const color = colors[mode];
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.isExplosion ? 
                    color.line + (this.life * 0.8) + ')' : 
                    color.primary;
                ctx.fill();
                
                // 发光效果
                if (!this.isExplosion || this.life > 0.5) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = color.glow;
                }
            }
        }

        // 创建粒子
        function initParticles() {
            particles = [];
            const particleCount = Math.min(120, Math.floor((width * height) / 15000));
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }

        // 绘制连线
        function drawConnections() {
            const color = colors[mode];
            let connectionCount = 0;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 120) {
                        const opacity = (1 - distance / 120) * 0.5;
                        ctx.beginPath();
                        ctx.strokeStyle = color.line + opacity + ')';
                        ctx.lineWidth = 0.8;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                        connectionCount++;
                    }
                }
                
                // 与鼠标的连线
                if (mouse.x != null && !particles[i].isExplosion) {
                    const dx = mouse.x - particles[i].x;
                    const dy = mouse.y - particles[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 200) {
                        const opacity = (1 - distance / 200) * 0.8;
                        ctx.beginPath();
                        ctx.strokeStyle = color.line + opacity + ')';
                        ctx.lineWidth = 1.2;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(mouse.x, mouse.y);
                        ctx.stroke();
                    }
                }
            }
            
            document.getElementById('connectionCount').textContent = connectionCount;
        }

        // 创建涟漪效果
        function createRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            ripple.style.borderColor = colors[mode].primary;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1000);
        }

        // 爆炸效果
        function createExplosion(x, y) {
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(x, y, true));
            }
            createRipple(x, y);
        }

        // 全员爆炸
        function explodeAll() {
            particles.forEach(p => {
                if (!p.isExplosion) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 15 + 5;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                }
            });
            
            // 创建多个涟漪
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createRipple(
                        Math.random() * width,
                        Math.random() * height
                    );
                }, i * 100);
            }
        }

        // 切换模式
        function changeMode(newMode) {
            mode = newMode;
        }

        // 切换重力
        function toggleGravity() {
            gravity = !gravity;
        }

        // 动画循环
        function animate(currentTime) {
            // 计算FPS
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
            }
            frameCount++;

            // 清除画布 - 使用半透明实现拖尾效果
            ctx.fillStyle = 'rgba(5, 5, 8, 0.15)';
            ctx.fillRect(0, 0, width, height);
            
            // 重置阴影
            ctx.shadowBlur = 0;
            
            // 更新和绘制粒子
            particles = particles.filter(p => {
                const alive = p.update();
                if (alive) p.draw();
                return alive;
            });
            
            // 补充粒子
            const targetCount = Math.min(120, Math.floor((width * height) / 15000));
            while (particles.filter(p => !p.isExplosion).length < targetCount) {
                particles.push(new Particle());
            }
            
            // 绘制连线
            drawConnections();
            
            // 更新统计
            document.getElementById('particleCount').textContent = particles.length;
            
            animationId = requestAnimationFrame(animate);
        }

        // 事件监听
        window.addEventListener('resize', () => {
            resize();
            initParticles();
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('mouseleave', () => {
            mouse.x = null;
            mouse.y = null;
        });

        window.addEventListener('click', (e) => {
            createExplosion(e.clientX, e.clientY);
        });

        window.addEventListener('touchmove', (e) => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        });

        window.addEventListener('touchend', () => {
            mouse.x = null;
            mouse.y = null;
        });

        window.addEventListener('touchstart', (e) => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            createExplosion(mouse.x, mouse.y);
        });

        // 初始化
        resize();
        initParticles();
        animate(0);
    </script>
</body>
</html>
